1. 构造函数
2. 析构函数
3. 拷贝构造函数
4. 拷贝赋值函数
       
   
第一步：我想要一个添加元素，删除元素，打印元素的类！
第二步：我要通过各种STL的容器去实现这三个操作！
第三步：我得去管理各个STL容器实现这三个操作。我来决定是使用哪个容器来操作！
第四步：这个三个操作使用多线程的方式测试！
第五步：使用智能指针去完成！


第一：为什么要写这四个函数 

    （1） 不写无参构造函数和析构函数，那么就放弃了自主初始化和清除的机会。
    （2） “默认拷贝构造函数”和“默认赋值函数”都是按照成员拷贝的默认方式实现。 它们会依次调用每一个数据成员的默认拷贝构造函数和默认赋值函数。一直到都是基本类型为止。
    （3）使用默认拷贝构造函数和默认赋值函数的危害是什么呢？
      假如类中有成员变量指针，那么按照默认拷贝构造函数和默认赋值数的执行结果来说，一个类的多个对象的对应成员指向的地址是同一块，那么当其中一个对象析构了，那么其他对象就不能指向这块地址了！很显然这不是我们想要的！


第二：为什么使用public？

      因为要给外面用！
    
第三：我个人理解的面向对象与面向过程的总体区别就是：

     面向对象是一个大的框架，业务，各个类之间的关系等大的对象与对象之间的关系，所以比较侧重类的质量；面向过程比较注重的是细节上解决问题的方法，步骤的高效与否，所以比较侧重算法，数据结构！

   所以想要写一个好的类，类的四个基本函数一定要很明白，下面开始！

第五：每个类中四个函数个数：
   
    有多个构造函数（其中包括一个拷贝构造函数，其他的为普通构造函数），多个赋值函数（包括一个拷贝赋值函数，其他的为普通赋值函数），但只有一个析构函数。所以在构造函数和析构一定要写，拷贝构造函数和拷贝赋值函数一般情况下也要写，因为继承等原因，成员变量一般会有指针。

第六：如何写这四个函数呢？  

1. 构造函数

   1.1 什么是构造函数？

   对象创建时自动调用的函数叫构造函数，负责完成一些准备工作。我的理解就是初始化类成员变量，new对象等。
   ***多态中构造函数决定了创建出来的对象到底是哪一个类创建出来的！***
   ***所以构造函数非常重要***
   这里我有一个常见的疑问：在一个类中会用到其他类的指针作为成员变量，我之前一直是在本类中的构造函数中去new它，然后在析构函数中去delete它，我认为这个要看具体作用，如果是为了传输数据到本类，那么就不用new/delete,因为在本类外面，肯定有new，不必在本类new，并且是外部与本类之间的数据交互，在本类中new不是很合理。
   源码描述就是

    class  CA
    {
    public:
       CA（）
       {
           m_pB = new CB; 
       }
       CA():m_pC(nullptr)
       {

       }
       ~CA()
       {
           if(nullptr != m_pB)
           {
               delete m_pB;
               m_pB = nullptr;
           }
           m_pC = nullptr;
       }
       public:
       //用法
       void set(CC* pc);
       {
           m_pC = pC;
       }
       CC* get()
       {
           return m_pC;
       }
       void dosome()
       {
           m_pC->get();
       }
       
    privte:
    CB* m_pB;
    CC* m_pC;
   }

   注意这种组合与继承关系！耳朵是头的一部分是组合，头有耳朵的功能；喜鹊（派生类）是一种鸟（基类）（is-a）关系

   1.2 初始化列表（初始化只用初始化列表，不用函数体内赋值）

     1). 如果类有继承关系，派生类可以直接在它的初始化列表中调用基类的特定构造用来向基类传递参数，因为我们不能在初始化对象的时候访问基类的数据成员。
     class Base{
     public:
         Base(int x);
     };
     class B:public Base{
         public:
         B(int a, int b);
     };
     B::B(int a, int b):Base(a)
     {
         ...
     }
     这个例子就是将类B的a传递给类A。
     2). 可以给成员变量传递值
     3). 常量属性的成员只能在初始化列表中赋值


   ***为什么用初始化列表初始化成员而不用赋值的方式呢？***
    如两个类A和B

    class A{
    pulic:
    A(void);//默认构造函数
    A(const A& other);//拷贝构造函数
    A& operator =(const A& other);//赋值函数
    };
    class B
    {
     public:
     B(const A& a);
     private:
     A m_a;
   }

    初始化列表方式
    B::B(const A& a):m_a(a)
    {
     ...
    } 
    赋值方式
    B::B(const A& a)
    {
      m_a = a;
    }
    1）使用初始化列表方式就是B的构造函数列表中调用了A的拷贝构造函数，从而将B类中的m_a初始化了。
    2） 第一步B创建了一个叫做m_a的对象，调用了默认构造函数，之后m_a = a,调用了类A的赋值函数。
    所以用初始化列表效率高！

    如果是基础类型的话，效率差不多！但还是养成习惯使用初始化列表方式初始化！
    一个很重要的地方就是列表初始化的时候如果有继承关系。一定要非常注意初始化顺序。按照声明的顺序初始化。

一个派生类的构造函数，第一步是调用其基类的的构造函数，第二步调用成员变量的构造函数，而每个基类又是递归上面两步操作，一直到最根类！
所以一个对象总是首先构造最根类的子对象，然后逐步向下扩展，直到将整个类构造起来！

     1.3. 构造函数的重载
     构造函数分为三种：无参数/有参数/拷贝构造函数，不要写全部参数都有默认值的有参数构造函数，会与无参数构造函数有二义性！
     拷贝构造函数的第一个参数必须是const 本类& ，之后的参数有的话则是有默认值，或者没有其他的参数。
     ***不是引用本类而是对象值的话，会导致无限递归调用拷贝构造函数！！，所以它是错误的，非法的！***

    
   *** 写代码还是要自己写的好！出问题也知道是哪里！避免将自己的工作交给编译器！***

2. 析构函数

    2.1 在接口类中一定要有析构函数？
      
    如果基类是多态类，那么必须把基类的析构函数定义为虚函数，这样就可以像其他虚函数一样实现动态绑定，不然可能有内存泄漏！

3. 拷贝构造函数和拷贝赋值函数如何写
    class A
    {
    public:
     A(const A& other)
     A& operator = (const A&other);
    private:
     int m_data;
     int m_iValue;
     ABC * m_pChar;
    }
    //深拷贝
    A::A(const A& other)
    {
      //将值直接赋值
       this->m_data = other.m_data;
       this->m_iValue = other.m_iValue;
      //如果成员变量是指针那么就要先计算大小，然后赋值
       
       memcpy(this->m_pChar,other.m_pChar,ilen);
    }

    A& A::operator=(const A& other)
    {
       //(1)检查自赋值
       if(this != &other)
       {
         //（2）分配新的内存资源，并复制内容
          int ilen = siseof(other.m_pChar)/sizeof(ABC);
          ABC *pTemp = new ABC[ilen];
          memcpy(pTemp,other.m_pChar,ilen);
          //(3)释放原有资源
          delete []m_pChar;
          m_pChar = temp;
          this->data = other.m_data;
          this->m_iValue = other.m_iValue; 
       }
      //返回本对象引用
      return *this;
     
    }
 


     



   