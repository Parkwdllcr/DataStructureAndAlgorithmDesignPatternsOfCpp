https://blog.csdn.net/zyhse/article/details/108751889

https://www.cnblogs.com/lonelycatcher/archive/2011/12/20/2294161.html

互斥锁、条件变量、信号量总结

互斥锁、条件变量、信号量是系统为是实现多线程（多进程）访问共享资源或共同协作的同步机制。

互斥锁：用于多线程互斥地访问共享资源。
1)语义为互斥地使用共享资源，在多线程需要互斥访问共享资源时应使用互斥锁，而不应使用其它同步机制。
2)虽然信号量能够实现互斥锁mutex功能，但信号量功能过于强大，在表示互斥方面其语义不明确，且浪费系统资源。
3)应用范围：多线程

条件变量：用于多个线程分时协作完成一项任务。
1)语义为在不满足自己工作的条件时，主动阻塞自己，同时释放CPU让其它线程工作，等待其它线程唤醒。否则，
  往下执行，完成一项任务中自己应分担那部分工作，任务完成之后唤醒阻塞在该任务的条件变量上的其它线程，
  让其它线程进行它们应分担的工作；
  在多线程需要线性分时协作完成一项任务时应使用条件变量，而不应使用其它同步机制。
2)为了防止测试条件时产生竞争，条件变量必须和互斥锁一起使用。
3)应用范围：多线程
4)通常条件变量是利用线程间共享的全局变量进行同步的一种机制。
如：有两个线程共同完成打印1到100这项任务，线程1打印其中的1-9、21-29、..等，线程2打印其中的10、20、30..等。

共享变量 i
共享变量 mutex
共享变量 cond

线程1：
for(i=1;i<=100;i++) 
{
      pthread_mutex_lock(&mutex);/*锁住互斥量*/
      while(i%10==0)/*条件不满足（或者说满足其它线程的条件）时就主动挂起自己，让其它线程工作*/
         pthread_cond_wait(&cond,&mutex);/*先解锁mutex，然后阻塞自己，等待其它线程唤醒*/
      printf("thead1:%d\n",i);
      pthread_cond_signal(&cond);/*唤醒阻塞在条件变量cond上的一个线程*/
      pthread_mutex_unlock(&mutex);/*解锁互斥量*/
      sleep(1);
}

线程2：
while(i<=100) 
{
      pthread_mutex_lock(&mutex);/*锁住互斥量*/
      while(i%10!=0)/*条件不满足（或者说满足其它线程的条件）时就主动挂起自己，让其它线程工作*/
         pthread_cond_wait(&cond,&mutex);/*先解锁mutex，然后阻塞自己，等待其它线程唤醒*/
      printf("thead2:%d\n",i);
      pthread_cond_signal(&cond); /*唤醒阻塞在条件变量cond上的一个线程*/
      pthread_mutex_unlock(&mutex);/*解锁互斥量*/
}

注意：测试条件必须使用while语句，不能使用if语句。当pthread_cond_wait语句被唤醒后需要继续测试条件。


信号量：用于多线程（多进程）同时使用多个（同一类）可用资源。
1)语义是可供使用的共享资源单位的计数器。在多线程（多进程）需要同时使用多个（用一类）可用资源时应使用信号量，而不应使用其它同步机制。
  而不应使用其它同步机制。
2)信号量不要求和互斥锁一起使用。当然，如果解决方案需中信号量的语义又有互斥的语义时，可按实际需要进行同时使用，但要注意使用次序。
3)应用范围：多线程或多进程




